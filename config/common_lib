#!/bin/bash


#############################################################################################################
# function list
# new function write at end
# 1 writeLog
#############################################################################################################


#  Output success test case log information
#  IN : $1 module name
#       $2 test case title
#  OUT: N/A
function writePass()
{
    local Test_Result="PASS"
    #echo "$Module_Name,""$JIRA_ID,""$Designed_Requirement_ID,""$Test_Case_ID,""$Test_Item,""$Test_Case_Title,""$Test_Result" >> ${REPORT_FILE}
    #This cmd used to report pass result to lava server
    #lava-test-case ${Module_Name}":"${Test_Case_Title} --result pass
    lava-test-case $1":"$2 --result pass
    return 0
}

#  Output fail test case log information
#  IN : $1 module name 
#       $2 test case title
#  OUT: N/A
function writeFail()
{
    local Test_Result="FAIL"
    #local Remark="$1"
    #echo "$Module_Name,""$JIRA_ID,""$Designed_Requirement_ID,""$Test_Case_ID,""$Test_Item,""$Test_Case_Title,""$Test_Result,""$Remark" >> ${REPORT_FILE}
    #This cmd used to report fail result to lava server
    #lava-test-case ${Module_Name}":"${Test_Case_Title} --result fail
    lava-test-case $1":"$2 --result fail
    return 0
}

# Output log file header
# IN : N/A
# OUT: N/A
function writeLogHeader
{
    echo "Module Name,JIRA ID,Designed Requirement ID,Test Case ID,Test Item,Test Case Title,Test Result,Remark" > ${REPORT_FILE}
    return 0
}

# Set trust relationship for two boards
# IN : N/A
# OUT: N/A
function setTrustRelation
{
    rm -f ~/.ssh/*
    expect -c '
        set timeout -1
        set back_ip '${BACK_IP}'
        spawn ssh-keygen -t rsa
        expect {
        "*save the key*id_rsa*" { send "\r"; exp_continue }
        "*verwrite*y/n*" { send "y\r"; exp_continue }
        "*passphrase*passphrase*" { send "\r"; exp_continue }
        "*same passphrase*" { send "\r" }
        }

        spawn scp -r /root/.ssh/id_rsa.pub root@${back_ip}:/root/.ssh/authorized_keys
        expect "Are you sure you want to continue connecting (yes/no)?"
        send "yes\r"
        sleep 10
        expect -re ".*password:"
        send "root\r"

        expect eof
        exit 0
    '

    return 0
}

####################################################################################
#add by hezhongyan
##################
#Alone Functions
OutLog()
{
    local nStatus=${1}
    local sStatus=${2}
    local sMsg=${3}
    local flLog=${4:-/dev/null}
    local bExitErr=${5:-false}

    local sLogA
    case "${nStatus}" in
    0)
        sStatus=${sStatus:-Info}
        sLogA=$(printf "%s[%3d]%s[%3d]%5s[${nStatus}]: %s" "${FUNCNAME[1]}" "${BASH_LINENO[0]}" "${FUNCNAME[0]}" ${LINENO} "${sStatus}" "${sMsg}")
        echo "${sLogA}"
        echo "${sLogA}" >> "${flLog}"
        ;;
    *)
        sStatus=${sStatus:-Error}
        sLogA=$(printf "%s[%3d]%s[%3d]%5s[${nStatus}]: %s" "${FUNCNAME[1]}" "${BASH_LINENO[0]}" "${FUNCNAME[0]}" ${LINENO} "${sStatus}" "${sMsg}")
        echo "${sLogA}" 1>&2
        echo "${sLogA}" >> "${flLog}"
        if [ "${bExitErr}" == "true" ]; then
            exit ${nStatus}
        fi
        ;;
    esac
}
export -f OutLog

LoadSourceFileParent()
{
    local drCur1=${1}
    local flFind1=${2}
    local varPaths=${3}
    local flLog=${4}
    local bExitErr=${5:-true}

    if [ -z "${drCur1}" -o -z "${flFind1}" ]; then
        g_sErrCur="directory or file name is empty"
        eval ${varPaths}=
        return
    fi

    local flPub1 s1 s2 s3
    flPub1=${drCur1}/${flFind1}
    if [ ! -f "${flPub1}" ]; then
        s1=$(find ${drCur1}/.. ${g_argFindMaxDepth} -type f -name "${flFind1}")
        if [ -z "${s1}" ]; then
            g_sErrCur="Not found ${flFind1}"
            OutLog 1 "Error" "${g_sErrCur}" "${flLog}" ${bExitErr}
        fi
        flPub1=${s1}
    fi
    eval ${varPaths}=\${flPub1}
}
export -f LoadSourceFileParent

##########
#Complex Functions
RunTable()
{
    local flTableOrigin=${1}
    local flTableStatus=${2}
    local drScript=${3}
    local flLog=${4:-/dev/null}

    echo "The base table used is "${1}

    local sPass
    sPass=$(echo "${g_statusPass}" |sed 's#\([]/*[]\)#\\\1#g')

    local sStatusTable
    sStatusTable=
    if [ -f "${flTableStatus}" ]; then
        if [ "${g_bTCsReset}" == "true" ]; then
            rm -f "${flTableStatus}"
        else
            sStatusTable=$(cat "${flTableStatus}")
        fi
    fi

    local sR0 sR1 sLevelR1 sLevelR2 sTTitle1 sTTitle2 sScript1 sScript2 sFuncNa
    local sStatus1 nRt1 bRun1 sLineStatus
    while read sR0; do
        sR1=$(echo "${sR0}" |sed "s/^[ \t]\+//;s/[ \t\r]\+\$//")
        if [ -z "${sR1}" ]; then
            continue
        fi

        sLevelR1=$(awk -F'\t' '{print $8}' <<< "${sR1}" |sed "s/^[ \t]\+//;s/[ \t]+\$//")
        sLevelR2=$(sed 's#\([]/*[]\)#\\\1#g' <<< "${sLevelR1}")
        sTTitle1=$(awk -F'\t' '{print $5}' <<< "${sR1}" |sed "s/^[ \t]\+//;s/[ \t]+\$//")
        sTTitle2=$(sed 's#\([]/*[]\)#\\\1#g' <<< "${sTTitle1}")
        sScript1=$(awk -F'\t' '{print $6}' <<< "${sR1}" |sed "s/^[ \t]\+//;s/[ \t]+\$//")
        sFuncNa=$(awk -F'\t' '{print $7}' <<< "${sR1}" |sed "s/^[ \t]\+//;s/[ \t]+\$//")
        
	#get the description of testcase
	sTESTCASE=$(awk -F'\t' '{print $4}' <<< "${sR1}" |sed "s/^[ \t]\+//;s/[ \t]+\$//")
        echo "Begin to run test case: "${sTESTCASE}

        g_sErrCur=
        grep -q "^${sLevelR2}\$" <<< "${g_sLevelRun}"
        if [ $? -ne 0 ]; then
	    echo "Skip the test case: "
            g_sErrCur="test case close"
            sStatus1=${g_statusClose}
        else
            nRt1=${g_nNone}
            bRun1=true
            echo "Check the script "${sScript1}" "${sScript2}"..."
            if [ -n "${sScript1}" ]; then
                LoadSourceFileParent "${drScript}" "${sScript1}" sScript2 "${flLog}" false
                if [ -n "${sScript2}" ]; then
		    echo "Begin to set up Env of script: "${sScript1}" "${sScript2}
                    . "${sScript2}"
                    if [ $? -ne 0 ]; then
			echo "Environment is not OK when running "${sScript1}" "${sScript2}
                        nRt1=${g_nBlock}
                        g_sErrCur="environment not OK"
                    fi
                else
		    echo "No found the script: "${sScript1}
                    bRun1=false
                    g_sErrCur="${sScript1} not exist"
                fi
            fi

            if ${bRun1}; then
                if [ -n "${sFuncNa}" ]; then
		    echo "Begin to run the function "${sFuncNa}
                    ${sFuncNa}
                    nRt1=$?
                else
	            echo "No found the function: "${sFuncNa}
                    g_sErrCur="function is empty"
                fi
            fi

            case ${nRt1} in
            ${g_nPass})
		writePass() "PCIE" "${sTESTCASE}"
                sStatus1=${g_statusPass}
                ;;
            ${g_nFail})
		writeFail() "PCIE" "${sTESTCASE}"
                sStatus1=${g_statusFail}
                ;;
            ${g_nBlock})
                sStatus1=${g_statusBlock}
                ;;
            ${g_nNone})
                sStatus1=${g_statusNone}
                ;;
            127)
                g_sErrCur="${sFuncNa} not exist"
                sStatus1=${g_statusNone}
                ;;
            *)
                sStatus1=${g_statusUndef}
                ;;
            esac
        fi

        if [ -z "${sTTitle1}" ]; then
            g_sErrCur="no title ${sR1}"
            sLineStatus=
        else
            sLineStatus=$(grep "${sTTitle2}" <<< "${sStatusTable}")
        fi
        if [ -n "${sLineStatus}" ]; then
            #更新状态表中这条用例的状态;
            grep -q "^${sPass}${g_sSplit}" <<< "${sLineStatus}"
            if [ $? -ne 0 ]; then
                sStatusTable=$(sed "/${sTTitle2}/d" <<< "${sStatusTable}")
                sStatusTable=${sStatusTable}$'\n'${sStatus1}${g_sSplit}${sTTitle1}${g_sSplit}${g_sErrCur}
            fi
        else
            sStatusTable=${sStatusTable}$'\n'${sStatus1}${g_sSplit}${sTTitle1}${g_sSplit}${g_sErrCur}
        fi
    done < "${flTableOrigin}"

    echo "${sStatusTable}" > "${flTableStatus}"
}
export -f RunTable

GenReport()
{
    local flTableOrigin=${1}
    local flTableStatus=${2}
    local sModule=${3}
    local flLog=${4:-/dev/null}

    local sPass sFail sStatus1 sSearch1 sSearch2 sMessage 
    sPass=$(echo "${g_statusPass}" |sed 's#\([]/*[]\)#\\\1#g')
    sFail=$(echo "${g_statusFail}" |sed 's#\([]/*[]\)#\\\1#g')

    if [ ! -f "${flTableStatus}" ]; then
        OutLog 1 "" "${flTableStatus} not exist." "${flLog}" true
    fi

    sTableOrigin=$(cat "${flTableOrigin}")

    local Module_Name JIRA_ID Designed_Requirement_ID Test_Case_ID Test_Item Test_Case_Title
    Module_Name=${sModule}
    while read sR0; do
        sR1=$(echo "${sR0}" |sed "s/^[ \t]\+//;s/[ \t\r]\+\$//")
        if [ -z "${sR1}" ]; then
            continue
        fi

        sStatus1=$(echo "${sR1}" |awk -F'\t' '{print $1}')
        sSearch1=$(echo "${sR1}" |awk -F'\t' '{print $2}')
        sSearch2=$(sed 's#\([]/*[]\)#\\\1#g' <<< "${sSearch1}")
        sMessage=$(echo "${sR1}" |awk -F'\t' '{print $3}')
        sTCLine1=$(grep -i "${sSearch2}" <<< "${sTableOrigin}" |sed "s/\r\+//g")
        if [ -n "${sTCLine1}" ]; then
            JIRA_ID=$(echo "${sTCLine1}" |awk -F'\t' '{print $1}')
            Designed_Requirement_ID=$(echo "${sTCLine1}" |awk -F'\t' '{print $2}')
            Test_Case_ID=$(echo "${sTCLine1}" |awk -F'\t' '{print $3}')
            Test_Item=$(echo "${sTCLine1}" |awk -F'\t' '{print $4}')
            Test_Case_Title=$(echo "${sTCLine1}" |awk -F'\t' '{print $5}')
            echo "${sStatus1}" |grep -q "^${sPass}\$"
            if [ $? -eq 0 ]; then
                writePass
            else
                echo "${sStatus1}" |grep -q "^${sFail}\$"
                if [ $? -eq 0 ]; then
                    writeFail "${sMessage}"
                fi
            fi
        fi
    done < "${flTableStatus}"
}
export -f GenReport

GenTable()
{
    local flTableStatus=${1}
    local flTableOutput=${2}
    local sModule=${3}
    local flLog=${4:-/dev/null}

    local sPass sFail sStatus1 sSearch1 sSearch2 sMessage 
    sPass=$(echo "${g_statusPass}" |sed 's#\([]/*[]\)#\\\1#g')
    sFail=$(echo "${g_statusFail}" |sed 's#\([]/*[]\)#\\\1#g')

    if [ ! -f "${flTableStatus}" ]; then
        OutLog 1 "" "${flTableStatus} not exist." "${flLog}" true
    fi

    local sTCsTable
    sTCsTable=$(cat "${g_flTCsTable}")${g__n}

    while read sR0; do
        sR1=$(echo "${sR0}" |sed "s/^[ \t]\+//;s/[ \t\r]\+\$//")
        if [ -z "${sR1}" ]; then
            continue
        fi

        sStatus1=$(echo "${sR1}" |awk -F'\t' '{print $1}')
        sSearch1=$(echo "${sR1}" |awk -F'\t' '{print $2}')
        sSearch2=$(sed 's#\([]/*[]\)#\\\1#g' <<< "${sSearch1}")
        sTCLine1=$(grep -i "${sSearch2}" "${g_flTCsTable}" |sed "s/\r\+//g")
        if [ -n "${sTCLine1}" ]; then
            sTCsTable=$(echo "${sTCsTable}" |sed "/${sSearch2}/s/^/${sStatus1}${g_sSplit}/")
        else
            sStatus1=${g_statusNone}
            sTCsTable=$(echo "${sTCsTable}" |sed "\${a ${sStatus1}${g_sSplit}${sSearch1}${g__n}q};")
        fi
    done < "${flTableStatus}"

    echo "${sTCsTable}" > "${flTableOutput}"
}
export -f GenTable

####################################################################################

